package flow_test

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/utils/unittest"
)

// TestEpochProtocolStateEntry_EpochPhase tests that all possible instances of an MinEpochStateEntry
// correctly compute the current epoch phase, taking into account EFM status and incorporated service events.
func TestEpochProtocolStateEntry_EpochPhase(t *testing.T) {

	t.Run("EFM triggered", func(t *testing.T) {
		t.Run("tentatively in staking phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseStaking, true)
			assert.Equal(t, flow.EpochPhaseFallback, entry.EpochPhase())
		})
		t.Run("tentatively in setup phase", func(t *testing.T) {
			// Caution, the following is a degenerate edge-case that should _never_ be generated by the
			// FallbackStateMachine. Specifically, the FallbackStateMachine should clear out
			// any tentative values for a subsequent epoch _unless_ that epoch is already committed.
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseSetup, true)
			assert.Equal(t, flow.EpochPhaseFallback, entry.EpochPhase())
		})
		t.Run("tentatively in committed phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseCommitted, true)
			assert.Equal(t, flow.EpochPhaseCommitted, entry.EpochPhase())
		})
	})

	t.Run("EFM not triggered", func(t *testing.T) {
		t.Run("tentatively in staking phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseStaking, false)
			assert.Equal(t, flow.EpochPhaseStaking, entry.EpochPhase())
		})
		t.Run("tentatively in setup phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseSetup, false)
			assert.Equal(t, flow.EpochPhaseSetup, entry.EpochPhase())
		})
		t.Run("tentatively in committed phase", func(t *testing.T) {
			entry := unittest.EpochProtocolStateEntryFixture(flow.EpochPhaseCommitted, false)
			assert.Equal(t, flow.EpochPhaseCommitted, entry.EpochPhase())
		})
	})
}

// TestNewRichProtocolStateEntry checks that NewRichEpochStateEntry creates valid identity tables depending on the state
// of epoch which is derived from the protocol state entry.
// It checks for correct handling of both valid and invalid inputs, ensuring that the function
// correctly validates epoch service event consistency and presence.
//
// Valid Cases:
//  1. staking-root-protocol-state:
//     - No previous epoch; current epoch is in staking phase.
//  2. staking-phase:
//     - Previous and current epochs exist; no next epoch.
//  3. setup-phase:
//     - Next epoch setup is present; next epoch commit is nil.
//  4. setup-after-spork:
//     - First epoch after spork; no previous epoch; next epoch setup is present.
//  5. commit-phase:
//     - Previous, current, and next epochs are fully populated.
//  6. commit-after-spork:
//     - First epoch after spork; current and next epochs are committed.
//
// Invalid Cases:
//  7. PreviousEpoch is set but PreviousEpochSetup is nil:
//     - Should panic or error due to missing required event.
//  8. PreviousEpoch.SetupID mismatch with PreviousEpochSetup.ID:
//     - Should return an error for mismatched setup commitment.
//  9. PreviousEpoch.CommitID mismatch with PreviousEpochCommit.ID:
//     - Should return an error for mismatched commit commitment.
//
// 10. PreviousEpoch is nil but PreviousEpochSetup is non-nil:
//   - Should return an error for unexpected extra data.
//
// 11. PreviousEpoch is nil but PreviousEpochCommit is non-nil:
//   - Should return an error for unexpected extra data.
//
// 12. CurrentEpoch.SetupID mismatch with CurrentEpochSetup.ID:
//   - Should return an error for mismatched setup event.
//
// 13. CurrentEpoch.CommitID mismatch with CurrentEpochCommit.ID:
//   - Should return an error for mismatched commit event.
//
// 14. NextEpoch is nil but NextEpochSetup is non-nil:
//   - Should return an error for unexpected setup event.
//
// 15. NextEpoch is nil but NextEpochCommit is non-nil:
//   - Should return an error for unexpected commit event.
//
// 16. NextEpoch.CommitID is non-zero but mismatches NextEpochCommit.ID:
//   - Should return an error for mismatched commit event.
//
// 17. NextEpoch.CommitID is zero but NextEpochCommit is non-nil:
//   - Should return an error for unexpected commit event.
func TestNewRichProtocolStateEntry(t *testing.T) {
	// 1. Conditions right after a spork:
	//  * no previous epoch exists from the perspective of the freshly-sporked protocol state
	//  * network is currently in the staking phase for the next epoch, hence no service events for the next epoch exist
	t.Run("staking-root-protocol-state", func(t *testing.T) {
		setup := unittest.EpochSetupFixture()
		currentEpochCommit := unittest.EpochCommitFixture()
		identities := make(flow.DynamicIdentityEntryList, 0, len(setup.Participants))
		for _, identity := range setup.Participants {
			identities = append(identities, &flow.DynamicIdentityEntry{
				NodeID:  identity.NodeID,
				Ejected: false,
			})
		}
		minStateEntry := &flow.MinEpochStateEntry{
			PreviousEpoch: nil,
			CurrentEpoch: flow.EpochStateContainer{
				SetupID:          setup.ID(),
				CommitID:         currentEpochCommit.ID(),
				ActiveIdentities: identities,
			},
			EpochFallbackTriggered: false,
		}
		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  minStateEntry,
				PreviousEpochSetup:  nil,
				PreviousEpochCommit: nil,
				CurrentEpochSetup:   setup,
				CurrentEpochCommit:  currentEpochCommit,
				NextEpochSetup:      nil,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseStaking, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)

		expectedIdentities, err := flow.BuildIdentityTable(
			setup.Participants,
			identities,
			nil,
			nil,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants")
	})

	// 2. Common situation during the staking phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * network is currently in the staking phase for the next epoch, hence no service events for the next epoch exist
	t.Run("staking-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture()
		epochStateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      nil,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseStaking, epochStateEntry.EpochPhase())

		epochRichStateEntry, err := flow.NewRichEpochStateEntry(epochStateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.PreviousEpochSetup.Participants,
			stateEntryFixture.PreviousEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, epochRichStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + previous epoch setup participants")
		assert.Nil(t, epochRichStateEntry.NextEpoch)
	})

	// 3. Common situation during the epoch setup phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * network is currently in the setup phase for the next epoch, i.e. EpochSetup event (starting setup phase) has already been observed
	t.Run("setup-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpochCommit = nil
			entry.NextEpoch.CommitID = flow.ZeroID
		})

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseSetup, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		assert.Nil(t, richStateEntry.NextEpochCommit)
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 4. Common situation during the epoch setup phase for first epoch after the spork
	//  * we are currently in Epoch N
	//  * there is no previous epoch as we are in the first epoch after the spork
	//  * network is currently in the setup phase for the next epoch, i.e. EpochSetup event (starting setup phase) has already been observed
	t.Run("setup-after-spork", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			// no previous epoch since we are in the first epoch
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
			entry.PreviousEpoch = nil

			// next epoch is setup but not committed
			entry.NextEpochCommit = nil
			entry.NextEpoch.CommitID = flow.ZeroID
		})
		// sanity check that previous epoch is not populated in `stateEntry`
		assert.Nil(t, stateEntryFixture.PreviousEpoch)
		assert.Nil(t, stateEntryFixture.PreviousEpochSetup)
		assert.Nil(t, stateEntryFixture.PreviousEpochCommit)

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     nil,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseSetup, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		assert.Nil(t, richStateEntry.NextEpochCommit)
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 5. Common situation during the epoch commit phase for epoch N+1
	//  * we are currently in Epoch N
	//  * previous epoch N-1 is known (specifically EpochSetup and EpochCommit events)
	//  * The network has completed the epoch commit phase, i.e. published the EpochSetup and EpochCommit events for epoch N+1.
	t.Run("commit-phase", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState())

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseCommitted, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntry.NextEpochSetup.Participants,
			stateEntry.NextEpoch.ActiveIdentities,
			stateEntry.CurrentEpochSetup.Participants,
			stateEntry.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 6. Common situation during the epoch commit phase for first epoch after the spork
	//  * we are currently in Epoch N
	//  * there is no previous epoch as we are in the first epoch after the spork
	//  * The network has completed the epoch commit phase, i.e. published the EpochSetup and EpochCommit events for epoch N+1.
	t.Run("commit-after-spork", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			// no previous epoch since we are in the first epoch
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
			entry.PreviousEpoch = nil
		})
		// sanity check that previous epoch is not populated in `stateEntryFixture`
		assert.Nil(t, stateEntryFixture.PreviousEpoch)
		assert.Nil(t, stateEntryFixture.PreviousEpochSetup)
		assert.Nil(t, stateEntryFixture.PreviousEpochCommit)

		stateEntry, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		assert.NoError(t, err)
		assert.Equal(t, flow.EpochPhaseCommitted, stateEntry.EpochPhase())

		richStateEntry, err := flow.NewRichEpochStateEntry(stateEntry)
		assert.NoError(t, err)
		expectedIdentities, err := flow.BuildIdentityTable(
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.CurrentEpochIdentityTable, "should be equal to current epoch setup participants + next epoch setup participants")
		expectedIdentities, err = flow.BuildIdentityTable(
			stateEntryFixture.NextEpochSetup.Participants,
			stateEntryFixture.NextEpoch.ActiveIdentities,
			stateEntryFixture.CurrentEpochSetup.Participants,
			stateEntryFixture.CurrentEpoch.ActiveIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)
		assert.Equal(t, expectedIdentities, richStateEntry.NextEpochIdentityTable, "should be equal to next epoch setup participants + current epoch setup participants")
	})

	// 7. Invalid: PreviousEpoch is set, but PreviousEpochSetup is nil
	t.Run("invalid - previous epoch set but no setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 8. Invalid: PreviousEpoch.SetupID doesn't match PreviousEpochSetup.ID()
	t.Run("invalid - previous setup ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch.SetupID = flow.ZeroID // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 9. Invalid: PreviousEpoch.CommitID doesn't match PreviousEpochCommit.ID()
	t.Run("invalid - previous commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch.CommitID = flow.ZeroID // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 10. Invalid: PreviousEpoch is nil, but PreviousEpochSetup is non-nil
	t.Run("invalid - nil previous epoch but has setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no previous epoch but gotten non-nil EpochSetup")
	})

	// 11. Invalid: PreviousEpoch is nil, but PreviousEpochCommit is non-nil
	t.Run("invalid - nil previous epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
			entry.PreviousEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no previous epoch but gotten non-nil EpochCommit")
	})

	// 12. Invalid: CurrentEpoch.SetupID doesn't match CurrentEpochSetup.ID()
	t.Run("invalid - current setup ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.CurrentEpoch.SetupID = flow.ZeroID // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 13. Invalid: CurrentEpoch.CommitID doesn't match CurrentEpochCommit.ID()
	t.Run("invalid - current commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.CurrentEpoch.CommitID = flow.ZeroID // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 14. Invalid: NextEpoch is nil, but NextEpochSetup is non-nil
	t.Run("invalid - nil next epoch but has setup event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no next epoch but gotten non-nil EpochSetup event")
	})

	// 15. Invalid: NextEpoch is nil, but NextEpochCommit is non-nil
	t.Run("invalid - nil next epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch = nil
			entry.NextEpochSetup = nil
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "no next epoch but gotten non-nil EpochCommit")
	})

	// 16. Invalid: NextEpoch.CommitID ≠ ZeroID, but NextEpochCommit.ID doesn't match
	t.Run("invalid - next commit ID mismatch", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch.CommitID = unittest.IdentifierFixture() // incorrect
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "does not match commitment")
	})

	// 17. Invalid: NextEpoch.CommitID == ZeroID, but NextEpochCommit is non-nil
	t.Run("invalid - uncommitted next epoch but has commit event", func(t *testing.T) {
		stateEntryFixture := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState(), func(entry *flow.RichEpochStateEntry) {
			entry.NextEpoch.CommitID = flow.ZeroID
		})
		_, err := flow.NewEpochStateEntry(
			flow.UntrustedEpochStateEntry{
				MinEpochStateEntry:  stateEntryFixture.MinEpochStateEntry,
				PreviousEpochSetup:  stateEntryFixture.PreviousEpochSetup,
				PreviousEpochCommit: stateEntryFixture.PreviousEpochCommit,
				CurrentEpochSetup:   stateEntryFixture.CurrentEpochSetup,
				CurrentEpochCommit:  stateEntryFixture.CurrentEpochCommit,
				NextEpochSetup:      stateEntryFixture.NextEpochSetup,
				NextEpochCommit:     stateEntryFixture.NextEpochCommit,
			},
		)
		require.Error(t, err)
		require.Contains(t, err.Error(), "next epoch not yet committed but got EpochCommit event")
	})
}

// TestProtocolStateEntry_Copy tests if the copy method returns a deep copy of the entry.
// All changes to copy shouldn't affect the original entry -- except for key changes.
func TestProtocolStateEntry_Copy(t *testing.T) {
	entry := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState()).MinEpochStateEntry
	cpy := entry.Copy()
	assert.Equal(t, entry, cpy)
	assert.NotSame(t, entry.NextEpoch, cpy.NextEpoch)
	assert.NotSame(t, entry.PreviousEpoch, cpy.PreviousEpoch)

	cpy.EpochFallbackTriggered = !entry.EpochFallbackTriggered
	assert.NotEqual(t, entry, cpy)

	assertEpochContainer := func(entry, cpy *flow.EpochStateContainer) {
		assert.Equal(t, entry.ActiveIdentities[0], cpy.ActiveIdentities[0])
		cpy.ActiveIdentities[0].Ejected = true
		assert.NotEqual(t, entry.ActiveIdentities[0], cpy.ActiveIdentities[0])

		cpy.ActiveIdentities = append(cpy.ActiveIdentities, &flow.DynamicIdentityEntry{
			NodeID:  unittest.IdentifierFixture(),
			Ejected: false,
		})
		assert.NotEqual(t, entry.ActiveIdentities, cpy.ActiveIdentities)

		cpy.EpochExtensions = append(cpy.EpochExtensions, flow.EpochExtension{
			FirstView: 13,
		})
		assert.NotEqual(t, entry.EpochExtensions, cpy.EpochExtensions)
	}
	assertEpochContainer(entry.PreviousEpoch, cpy.PreviousEpoch)
	assertEpochContainer(&entry.CurrentEpoch, &cpy.CurrentEpoch)
	assertEpochContainer(entry.NextEpoch, cpy.NextEpoch)
}

// TestEpochStateEntry_EpochCounter tests if the epoch counter is correctly computed for the entry.
// The epoch counter should be equal to the counter of the current epoch setup and commit regardless of the previous or next epoch.
func TestEpochStateEntry_EpochCounter(t *testing.T) {
	t.Run("with-previous-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
	t.Run("root-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture(func(entry *flow.RichEpochStateEntry) {
			entry.PreviousEpoch = nil
			entry.PreviousEpochSetup = nil
			entry.PreviousEpochCommit = nil
		})
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
	t.Run("with-next-epoch", func(t *testing.T) {
		entry := unittest.EpochStateFixture(unittest.WithNextEpochProtocolState())
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochSetup.Counter)
		assert.Equal(t, entry.EpochCounter(), entry.CurrentEpochCommit.Counter)
	})
}

// TestEpochStateEntry_CurrentEpochFinalView tests if the final view of the current epoch is correctly computed,
// it has to be equal:
// - to the final view of the current epoch setup if there are no extensions
// - to the final view of the last extension if there are multiple extensions
func TestEpochStateEntry_CurrentEpochFinalView(t *testing.T) {
	t.Run("no-extension", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		assert.Equal(t, entry.CurrentEpochSetup.FinalView, entry.CurrentEpochFinalView())
	})
	t.Run("multiple-extension", func(t *testing.T) {
		entry := unittest.EpochStateFixture()
		extraViews := uint64(1000)
		entry.CurrentEpoch.EpochExtensions = []flow.EpochExtension{
			{
				FirstView: entry.CurrentEpochSetup.FinalView + 1,
				FinalView: entry.CurrentEpochSetup.FinalView + extraViews,
			},
		}
		assert.Equal(t, entry.CurrentEpochSetup.FinalView+extraViews, entry.CurrentEpochFinalView())
		entry.CurrentEpoch.EpochExtensions = append(entry.CurrentEpoch.EpochExtensions, flow.EpochExtension{
			FirstView: entry.CurrentEpoch.EpochExtensions[0].FinalView + 1,
			FinalView: entry.CurrentEpoch.EpochExtensions[0].FinalView + extraViews,
		})
		assert.Equal(t, entry.CurrentEpochSetup.FinalView+2*extraViews, entry.CurrentEpochFinalView())
	})
}

// TestBuildIdentityTable tests if BuildIdentityTable returns a correct identity, whenever we pass arguments with or without
// overlap. It also tests if the function returns an error when the arguments are not ordered in the same order.
func TestBuildIdentityTable(t *testing.T) {
	t.Run("invalid-adjacent-identity-status", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])

		// Per convention, BuildIdentityTable only accepts EpochParticipationStatusLeaving or EpochParticipationStatusJoining
		// for the *adjacent* epoch, because these are the only sensible values.
		for _, status := range []flow.EpochParticipationStatus{flow.EpochParticipationStatusActive, flow.EpochParticipationStatusEjected} {
			identityList, err := flow.BuildIdentityTable(
				targetEpochIdentities.ToSkeleton(),
				flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
				adjacentEpochIdentities.ToSkeleton(),
				flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
				status,
			)
			assert.Error(t, err)
			assert.Empty(t, identityList)
		}
	})
	t.Run("happy-path-no-identities-overlap", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])

		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusLeaving,
		)
		assert.NoError(t, err)

		expectedIdentities := targetEpochIdentities.Union(adjacentEpochIdentities.Map(func(identity flow.Identity) flow.Identity {
			identity.EpochParticipationStatus = flow.EpochParticipationStatusLeaving
			return identity
		}))
		assert.Equal(t, expectedIdentities, identityList)
	})
	t.Run("happy-path-identities-overlap", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentities := unittest.IdentityListFixture(10)
		sampledIdentities, err := targetEpochIdentities.Sample(2)
		// change address so we can assert that we take identities from target epoch and not adjacent epoch
		for i, identity := range sampledIdentities.Copy() {
			identity.Address = fmt.Sprintf("%d", i)
			adjacentEpochIdentities = append(adjacentEpochIdentities, identity)
		}
		assert.NoError(t, err)
		adjacentEpochIdentities = adjacentEpochIdentities.Sort(flow.Canonical[flow.Identity])

		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusJoining,
		)
		assert.NoError(t, err)

		expectedIdentities := targetEpochIdentities.Union(adjacentEpochIdentities.Map(func(identity flow.Identity) flow.Identity {
			identity.EpochParticipationStatus = flow.EpochParticipationStatusJoining
			return identity
		}))
		assert.Equal(t, expectedIdentities, identityList)
	})
	t.Run("target-epoch-identities-not-ordered", func(t *testing.T) {
		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		targetEpochIdentitySkeletons, err := targetEpochIdentities.ToSkeleton().Shuffle()
		assert.NoError(t, err)
		targetEpochDynamicIdentities := flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities)

		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentitySkeletons,
			targetEpochDynamicIdentities,
			adjacentEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities),
			flow.EpochParticipationStatusLeaving,
		)
		assert.Error(t, err)
		assert.Empty(t, identityList)
	})
	t.Run("adjacent-epoch-identities-not-ordered", func(t *testing.T) {
		adjacentEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		adjacentEpochIdentitySkeletons, err := adjacentEpochIdentities.ToSkeleton().Shuffle()
		assert.NoError(t, err)
		adjacentEpochDynamicIdentities := flow.DynamicIdentityEntryListFromIdentities(adjacentEpochIdentities)

		targetEpochIdentities := unittest.IdentityListFixture(10).Sort(flow.Canonical[flow.Identity])
		identityList, err := flow.BuildIdentityTable(
			targetEpochIdentities.ToSkeleton(),
			flow.DynamicIdentityEntryListFromIdentities(targetEpochIdentities),
			adjacentEpochIdentitySkeletons,
			adjacentEpochDynamicIdentities,
			flow.EpochParticipationStatusLeaving,
		)
		assert.Error(t, err)
		assert.Empty(t, identityList)
	})
}

// TestNewMinEpochStateEntry validates the behavior of the NewMinEpochStateEntry constructor function.
// It checks for correct handling of both valid and invalid inputs.
//
// Test Cases:
//
// 1. Valid input with all fields:
//   - Ensures that providing a valid current epoch and optional previous/next epochs creates a MinEpochStateEntry.
//
// 2. Valid input with nil PreviousEpoch and NextEpoch:
//   - Ensures that entry construction still succeeds with only CurrentEpoch.
//
// 3. Invalid input: empty CurrentEpoch:
//   - Verifies that constructor returns an error if CurrentEpoch is not populated.
func TestNewMinEpochStateEntry(t *testing.T) {
	identities := unittest.DynamicIdentityEntryListFixture(3)

	currentEpoch := flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	previousEpoch := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	nextEpoch := &flow.EpochStateContainer{
		SetupID:          unittest.IdentifierFixture(),
		CommitID:         unittest.IdentifierFixture(),
		ActiveIdentities: identities,
	}

	// 1. Valid input with all fields
	t.Run("valid input with all fields", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          previousEpoch,
			CurrentEpoch:           currentEpoch,
			NextEpoch:              nextEpoch,
			EpochFallbackTriggered: true,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 2. Valid input with nil PreviousEpoch and NextEpoch
	t.Run("valid input with nil PreviousEpoch and NextEpoch", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          nil,
			CurrentEpoch:           currentEpoch,
			NextEpoch:              nil,
			EpochFallbackTriggered: false,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.NoError(t, err)
		require.NotNil(t, entry)
	})

	// 3. Invalid input: empty CurrentEpoch
	t.Run("empty CurrentEpoch", func(t *testing.T) {
		untrusted := flow.UntrustedMinEpochStateEntry{
			PreviousEpoch:          nil,
			CurrentEpoch:           flow.EpochStateContainer{}, // Empty
			NextEpoch:              nil,
			EpochFallbackTriggered: false,
		}

		entry, err := flow.NewMinEpochStateEntry(untrusted)
		require.Error(t, err)
		require.Nil(t, entry)
		require.Contains(t, err.Error(), "current epoch must not be empty")
	})
}
